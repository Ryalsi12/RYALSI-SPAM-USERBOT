# tgvc-userbot, Telegram Voice Chat Userbot
# Copyright (C) 2021  Dash Eclipse
# Copyright (C) 2021  Hitalo

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
player.py (v0.7.0)

Play musics in Telegram voice chats through the UserLixo.

Author: @Hitalo
Channel: @UserLixoPlugins
GitHub: <a href='github.com/callsmusic/tgvc-userbot'>tgvc-userbot</a>

Requirements: wheel ffmpeg-python pytgcalls
Type: user
"""

import asyncio
import os
from datetime import datetime, timedelta
from typing import List

import ffmpeg
from pyrogram import Client, emoji, filters
from pyrogram.methods.messages.download_media import DEFAULT_DOWNLOAD_DIR
from pyrogram.types import Message
from pytgcalls import GroupCall
from userlixo.config import cmds

DELETE_DELAY = 8
DURATION_AUTOPLAY_MIN = 10
DURATION_PLAY_HOUR = 3

cmds.update(
    radio=f"""{emoji.LABEL}  <b>Common Commands</b>:
<i>available to group members of current voice chat</i>
<i>starts with / (slash) or ! (exclamation mark)</i>

\u2022 <b>/play</b>  reply with an audio to play/queue it, or show playlist
\u2022 <b>/current</b>  show current playing time of current track
\u2022 <b>/repo</b>  show git repository of the userbot


{emoji.LABEL}  <b>Admin Commands</b>:
<i>available to UserLixo account itself and sudoers</i>
<i>starts with your UserLixo commands prefix</i>

\u2022 <code>.skip</code> [n] ...  skip current or n where n >= 2
\u2022 <code>.join</code>  join voice chat of current group
\u2022 <code>.leave</code>  leave current voice chat
\u2022 <code>.vc</code>  check which VC is joined
\u2022 <code>.stop</code>  stop playing
\u2022 <code>.replay</code>  play from the beginning
\u2022 <code>.clean</code>  remove unused RAW PCM files
\u2022 <code>.pause</code> pause playing
\u2022 <code>.resume</code> resume playing
\u2022 <code>.mute</code>  mute the VC userbot
\u2022 <code>.unmute</code>  unmute the VC userbot
"""
)

USERBOT_REPO = f"""{emoji.ROBOT} <b>This is a TGVC port for UserLixo</b>
<i>Play songs in voice chats with UserLixo!</i>

UserLixo Repository: <a href=https://github.com/AmanoTeam/UserLixo>GitHub</a>
 - UserLixo License: MIT

TGVC Repository: <a href=https://github.com/callsmusic/tgvc-userbot>GitHub</a>
 - TGVC License: AGPL-3.0-or-later
"""

# - Pyrogram filters

main_filter = filters.group & filters.text & ~filters.edited & ~filters.via_bot


async def current_vc_filter(_, __, m: Message):
    group_call = mp.group_call
    if not group_call.is_connected:
        return False
    chat_id = int("-100" + str(group_call.full_chat.id))
    if m.chat.id == chat_id:
        return True
    return False


current_vc = filters.create(current_vc_filter)


# - class


class MusicPlayer(object):
    def __init__(self):
        self.group_call = GroupCall(None, path_to_log_file="")
        self.chat_id = None
        self.start_time = None
        self.playlist = []
        self.msg = {}

    async def update_start_time(self, reset=False):
        self.start_time = None if reset else datetime.utcnow().replace(microsecond=0)

    async def send_playlist(self):
        playlist = self.playlist
        if not playlist:
            pl = f"{emoji.NO_ENTRY} empty playlist"
        else:
            if len(playlist) == 1:
                pl = f"{emoji.REPEAT_SINGLE_BUTTON} <b>Playlist</b>:\n"
            else:
                pl = f"{emoji.PLAY_BUTTON} <b>Playlist</b>:\n"
            pl += "\n".join(
                [
                    f"<b>{i}</b>. <b><a href='{x.link}'>{x.audio.title}</a></b>"
                    for i, x in enumerate(playlist)
                ]
            )
        if mp.msg.get("playlist") is not None:
            await mp.msg["playlist"].delete()
        mp.msg["playlist"] = await send_text(pl)


mp = MusicPlayer()


# - pytgcalls handlers


@mp.group_call.on_network_status_changed
async def network_status_changed_handler(gc: GroupCall, is_connected: bool):
    if is_connected:
        mp.chat_id = int("-100" + str(gc.full_chat.id))
        await send_text(f"{emoji.CHECK_MARK_BUTTON} joined the voice chat")
    else:
        await send_text(f"{emoji.CROSS_MARK_BUTTON} left the voice chat")
        mp.chat_id = None


@mp.group_call.on_playout_ended
async def playout_ended_handler(_, __):
    await skip_current_playing()


# - Pyrogram handlers


@Client.on_message(
    filters.group
    & ~filters.edited
    & current_vc
    & (filters.regex("^(\\/|!)play$") | filters.audio)
)
async def play_track(c: Client, m: Message):
    group_call = mp.group_call
    playlist = mp.playlist
    # check audio
    if m.audio:
        if m.audio.duration > (DURATION_AUTOPLAY_MIN * 60):
            reply = await m.reply_text(
                f"{emoji.ROBOT} audio which duration longer than "
                f"{str(DURATION_AUTOPLAY_MIN)} min won't be automatically "
                "added to playlist"
            )
            await _delay_delete_messages((reply,), DELETE_DELAY)
            return
        m_audio = m
    elif m.reply_to_message and m.reply_to_message.audio:
        m_audio = m.reply_to_message
        if m_audio.audio.duration > (DURATION_PLAY_HOUR * 60 * 60):
            reply = await m.reply_text(
                f"{emoji.ROBOT} audio which duration longer than "
                f"{str(DURATION_PLAY_HOUR)} hours won't be added to playlist"
            )
            await _delay_delete_messages((reply,), DELETE_DELAY)
            return
    else:
        await mp.send_playlist()
        await m.delete()
        return
    # check already added
    if playlist and playlist[-1].audio.file_unique_id == m_audio.audio.file_unique_id:
        reply = await m.reply_text(f"{emoji.ROBOT} already added")
        await _delay_delete_messages((reply, m), DELETE_DELAY)
        return
    # add to playlist
    playlist.append(m_audio)
    if len(playlist) == 1:
        m_status = await m.reply_text(
            f"{emoji.INBOX_TRAY} downloading and transcoding..."
        )
        await download_audio(playlist[0])
        group_call.input_filename = os.path.join(
            c.workdir,
            DEFAULT_DOWNLOAD_DIR,
            f"{playlist[0].audio.file_unique_id}.raw",
        )
        await mp.update_start_time()
        await m_status.delete()
        print(f"- START PLAYING: {playlist[0].audio.title}")
    await mp.send_playlist()
    for track in playlist[:2]:
        await download_audio(track)
    if not m.audio:
        await m.delete()


@Client.on_message(main_filter & current_vc & filters.regex("^(\\/|!)current$"))
async def show_current_playing_time(c: Client, m: Message):
    start_time = mp.start_time
    playlist = mp.playlist
    if not start_time:
        reply = await m.reply_text(f"{emoji.PLAY_BUTTON} unknown")
        await _delay_delete_messages((reply, m), DELETE_DELAY)
        return
    utcnow = datetime.utcnow().replace(microsecond=0)
    if mp.msg.get("current") is not None:
        await mp.msg["current"].delete()
    mp.msg["current"] = await playlist[0].reply_text(
        f"{emoji.PLAY_BUTTON}  {utcnow - start_time} / "
        f"{timedelta(seconds=playlist[0].audio.duration)}",
        disable_notification=True,
    )
    await m.delete()


@Client.on_message(main_filter & current_vc & filters.su_cmd("skip"))
async def skip_track(c: Client, m: Message):
    playlist = mp.playlist
    splitted = m.text.split(" ")
    if len(splitted) == 1:
        await skip_current_playing()
    else:
        try:
            items = list(dict.fromkeys(splitted[1:]))
            items = [int(x) for x in items if x.isdigit()]
            items.sort(reverse=True)
            text = []
            for i in items:
                if 2 <= i <= (len(playlist) - 1):
                    audio = (
                        f"<a href='{playlist[i].link}'>{playlist[i].audio.title}</a>"
                    )
                    playlist.pop(i)
                    text.append(f"{emoji.WASTEBASKET} {i}. <b>{audio}</b>")
                else:
                    text.append(f"{emoji.CROSS_MARK} {i}")
            reply = await m.reply_text("\n".join(text), disable_web_page_preview=True)
            await mp.send_playlist()
        except (ValueError, TypeError):
            reply = await m.reply_text(
                f"{emoji.NO_ENTRY} invalid input", disable_web_page_preview=True
            )
        await _delay_delete_messages((reply, m), DELETE_DELAY)


@Client.on_message(main_filter & filters.su_cmd("join$"))
async def join_group_call(c: Client, m: Message):
    group_call = mp.group_call
    group_call.client = c
    if group_call.is_connected:
        await m.reply_text(f"{emoji.ROBOT} already joined a voice chat")
        return
    await group_call.start(m.chat.id)
    await m.delete()


@Client.on_message(main_filter & current_vc & filters.su_cmd("leave$"))
async def leave_voice_chat(c: Client, m: Message):
    group_call = mp.group_call
    mp.playlist.clear()
    group_call.input_filename = ""
    await group_call.stop()
    await m.delete()


@Client.on_message(main_filter & filters.su_cmd("vc$"))
async def list_voice_chat(c: Client, m: Message):
    group_call = mp.group_call
    if group_call.is_connected:
        chat_id = int("-100" + str(group_call.full_chat.id))
        chat = await c.get_chat(chat_id)
        reply = await m.reply_text(
            f"{emoji.MUSICAL_NOTES} <b>currently in the voice chat</b>:\n"
            f"- <b>{chat.title}</b>"
        )
    else:
        reply = await m.reply_text(emoji.NO_ENTRY + "didn't join any voice chat yet")
    await _delay_delete_messages((reply, m), DELETE_DELAY)


@Client.on_message(main_filter & current_vc & filters.su_cmd("stop$"))
async def stop_playing(c: Client, m: Message):
    group_call = mp.group_call
    group_call.stop_playout()
    reply = await m.reply_text(f"{emoji.STOP_BUTTON} stopped playing")
    await mp.update_start_time(reset=True)
    mp.playlist.clear()
    await _delay_delete_messages((reply, m), DELETE_DELAY)


@Client.on_message(main_filter & current_vc & filters.su_cmd("replay$"))
async def restart_playing(c: Client, m: Message):
    group_call = mp.group_call
    if not mp.playlist:
        return
    group_call.restart_playout()
    await mp.update_start_time()
    reply = await m.reply_text(
        f"{emoji.COUNTERCLOCKWISE_ARROWS_BUTTON}  " "playing from the beginning..."
    )
    await _delay_delete_messages((reply, m), DELETE_DELAY)


@Client.on_message(main_filter & current_vc & filters.su_cmd("pause"))
async def pause_playing(c: Client, m: Message):
    mp.group_call.pause_playout()
    await mp.update_start_time(reset=True)
    reply = await m.reply_text(f"{emoji.PLAY_OR_PAUSE_BUTTON} paused", quote=False)
    mp.msg["pause"] = reply
    await m.delete()


@Client.on_message(main_filter & current_vc & filters.su_cmd("resume"))
async def resume_playing(c: Client, m: Message):
    mp.group_call.resume_playout()
    reply = await m.reply_text(f"{emoji.PLAY_OR_PAUSE_BUTTON} resumed", quote=False)
    if mp.msg.get("pause") is not None:
        await mp.msg["pause"].delete()
    await m.delete()
    await _delay_delete_messages((reply,), DELETE_DELAY)


@Client.on_message(main_filter & current_vc & filters.su_cmd("clean$"))
async def clean_raw_pcm(c: Client, m: Message):
    download_dir = os.path.join(c.workdir, DEFAULT_DOWNLOAD_DIR)
    all_fn: list[str] = os.listdir(download_dir)
    for track in mp.playlist[:2]:
        track_fn = f"{track.audio.file_unique_id}.raw"
        if track_fn in all_fn:
            all_fn.remove(track_fn)
    count = 0
    if all_fn:
        for fn in all_fn:
            if fn.endswith(".raw"):
                count += 1
                os.remove(os.path.join(download_dir, fn))
    reply = await m.reply_text(f"{emoji.WASTEBASKET} cleaned {count} files")
    await _delay_delete_messages((reply, m), DELETE_DELAY)


@Client.on_message(main_filter & current_vc & filters.su_cmd("mute$"))
async def mute(c: Client, m: Message):
    group_call = mp.group_call
    group_call.set_is_mute(True)
    reply = await m.reply_text(f"{emoji.MUTED_SPEAKER} muted")
    await _delay_delete_messages((reply, m), DELETE_DELAY)


@Client.on_message(main_filter & current_vc & filters.su_cmd("unmute$"))
async def unmute(c: Client, m: Message):
    group_call = mp.group_call
    group_call.set_is_mute(False)
    reply = await m.reply_text(f"{emoji.SPEAKER_MEDIUM_VOLUME} unmuted")
    await _delay_delete_messages((reply, m), DELETE_DELAY)


@Client.on_message(main_filter & current_vc & filters.regex("^(\\/|!)repo$"))
async def show_repository(c: Client, m: Message):
    if mp.msg.get("repo") is not None:
        await mp.msg["repo"].delete()
    mp.msg["repo"] = await m.reply_text(
        USERBOT_REPO, disable_web_page_preview=True, quote=False
    )
    await m.delete()


# - Other functions


async def send_text(text: str):
    group_call = mp.group_call
    c = group_call.client
    chat_id = mp.chat_id
    message = await c.send_message(
        chat_id,
        text,
        disable_web_page_preview=True,
        disable_notification=True,
    )
    return message


async def skip_current_playing():
    group_call = mp.group_call
    playlist = mp.playlist
    if not playlist:
        return
    if len(playlist) == 1:
        await mp.update_start_time()
        return
    c = group_call.client
    download_dir = os.path.join(c.workdir, DEFAULT_DOWNLOAD_DIR)
    group_call.input_filename = os.path.join(
        download_dir, f"{playlist[1].audio.file_unique_id}.raw"
    )
    await mp.update_start_time()
    # remove old track from playlist
    old_track = playlist.pop(0)
    print(f"- START PLAYING: {playlist[0].audio.title}")
    await mp.send_playlist()
    os.remove(os.path.join(download_dir, f"{old_track.audio.file_unique_id}.raw"))
    if len(playlist) == 1:
        return
    await download_audio(playlist[1])


async def download_audio(m: Message):
    group_call = mp.group_call
    c = group_call.client
    raw_file = os.path.join(
        c.workdir, DEFAULT_DOWNLOAD_DIR, f"{m.audio.file_unique_id}.raw"
    )
    if not os.path.isfile(raw_file):
        original_file = await m.download()
        ffmpeg.input(original_file).output(
            raw_file,
            format="s16le",
            acodec="pcm_s16le",
            ac=2,
            ar="48k",
            loglevel="error",
        ).overwrite_output().run()
        os.remove(original_file)


async def _delay_delete_messages(messages: tuple, delay: int):
    await asyncio.sleep(delay)
    for m in messages:
        await m.delete()
